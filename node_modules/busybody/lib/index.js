'use strict';

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _onFinished = require('on-finished');

var _onFinished2 = _interopRequireDefault(_onFinished);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _round = require('lodash/round');

var _round2 = _interopRequireDefault(_round);

var _map = require('lodash/map');

var _map2 = _interopRequireDefault(_map);

var _head = require('lodash/head');

var _head2 = _interopRequireDefault(_head);

var _mergeDescriptors = require('merge-descriptors');

var _mergeDescriptors2 = _interopRequireDefault(_mergeDescriptors);

var _events = require('events');

var _sdStream = require('./sd-stream');

var _sdStream2 = _interopRequireDefault(_sdStream);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var UUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
var ID = /^\d+$/;

var debug = (0, _debug2.default)('busybody');
var defaultStep = _debug2.default.humanize('6 hours');
var defaultWindow = 4;
var defaultPrecision = 2;
var defaultMaxSize = 500;
var defaultPreFilter = function defaultPreFilter() {
  return true;
};
var defaultPostFilter = function defaultPostFilter() {
  return true;
};
var defaultSanitize = function defaultSanitize(req) {
  // get normalized pathname

  var _url$parse = _url2.default.parse(req.originalUrl);

  var pathname = _url$parse.pathname;

  pathname = pathname || '/';
  pathname = pathname.toLowerCase();
  pathname = _path2.default.normalize(pathname + '/./');

  // sanitize each part of it
  return pathname.split('/').map(function (part) {
    if (ID.test(part)) return ':id';
    if (UUID.test(part)) return ':uuid';
    return part;
  }).join('/');
};

function busybody() {
  var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var _ref$step = _ref.step;
  var step = _ref$step === undefined ? defaultStep : _ref$step;
  var _ref$window = _ref.window;
  var window = _ref$window === undefined ? defaultWindow : _ref$window;
  var _ref$maxSize = _ref.maxSize;
  var maxSize = _ref$maxSize === undefined ? defaultMaxSize : _ref$maxSize;
  var _ref$precision = _ref.precision;
  var precision = _ref$precision === undefined ? defaultPrecision : _ref$precision;
  var _ref$preFilter = _ref.preFilter;
  var preFilter = _ref$preFilter === undefined ? defaultPreFilter : _ref$preFilter;
  var _ref$postFilter = _ref.postFilter;
  var postFilter = _ref$postFilter === undefined ? defaultPostFilter : _ref$postFilter;
  var _ref$sanitize = _ref.sanitize;
  var sanitize = _ref$sanitize === undefined ? defaultSanitize : _ref$sanitize;
  var _ref$onStep = _ref.onStep;
  var onStep = _ref$onStep === undefined ? null : _ref$onStep;
  var _ref$onExpire = _ref.onExpire;
  var onExpire = _ref$onExpire === undefined ? null : _ref$onExpire;

  (0, _assert2.default)(step >= 0, 'step must be a positive number');
  (0, _assert2.default)(window > 0, 'window must be a positive non-zero number');
  (0, _assert2.default)(window > 0, 'window must be a positive non-zero number');
  (0, _assert2.default)(precision >= 0, 'precision must be a positive number');
  (0, _assert2.default)(typeof preFilter === 'function', 'preFilter must be a function');
  (0, _assert2.default)(typeof postFilter === 'function', 'postfilter must be a function');
  (0, _assert2.default)(typeof sanitize === 'function', 'filter must be a function');

  var intervals = [];

  // calcs time from start in ms
  function diff(start) {
    var hr = process.hrtime(start);
    var ms = hr[0] * 1e3 + hr[1] / 1e6;
    return (0, _round2.default)(ms, precision);
  }

  function push(key, ms) {
    intervals.forEach(function (interval) {
      if (!interval.streams[key]) {
        // check that our size is good before tracking any keys
        if (interval.size >= maxSize) {
          debug('cannot track any more keys');
          return;
        }

        interval.streams[key] = new _sdStream2.default();
        interval.size = interval.size + 1;
      }
      interval.streams[key].push(ms);
    });
  }

  // onFinished listener to record response time
  function recordTime(err, res) {
    if (!res.req.busybody || !postFilter(err, res.req, res)) {
      return;
    }

    var key = sanitize(res.req, res);
    var start = res.req.busybody;
    var ms = diff(start);
    push(key, ms);
  }

  // the middleware function to track stats
  function statsMiddleware(req, res, next) {
    if (req.busybody || !preFilter(req, req)) {
      return next();
    }

    req.busybody = process.hrtime();
    (0, _onFinished2.default)(res, recordTime);

    return next();
  }

  // returns the formatted stats of the oldest interval
  function getStats() {
    var sort = arguments.length <= 0 || arguments[0] === undefined ? 'mean' : arguments[0];

    debug('calculating stats');
    var _intervals$ = intervals[0];
    var since = _intervals$.since;
    var streams = _intervals$.streams;
    var size = _intervals$.size;

    var closed = size === maxSize;

    var routes = (0, _map2.default)(streams, function (stream, key) {
      return {
        route: key,
        count: stream.count(),
        mean: (0, _round2.default)(stream.mean(), precision),
        standardDeviation: (0, _round2.default)(stream.standardDeviation(), precision),
        min: (0, _round2.default)(stream.min(), precision),
        max: (0, _round2.default)(stream.max(), precision)
      };
    });

    // sort in-place
    routes.sort(function (a, b) {
      return b[sort] - a[sort];
    });

    return {
      since: since,
      closed: closed,
      routes: routes
    };
  }

  // adds a new interval
  function addInterval() {
    debug('adding new interval');
    var newStep = {
      since: new Date().toISOString(),
      streams: {},
      size: 0
    };

    if (intervals.length >= window) {
      debug('removing expired interval');
      statsMiddleware.emit('expire', (0, _head2.default)(intervals));
      intervals.shift();
    }

    intervals.push(newStep);
    statsMiddleware.emit('step', newStep);
  }

  // expose some properties/event emitter
  statsMiddleware.intervals = intervals;
  statsMiddleware.addInterval = addInterval;
  statsMiddleware.getStats = getStats;
  statsMiddleware.push = push;
  (0, _mergeDescriptors2.default)(statsMiddleware, _events.EventEmitter.prototype, false);

  if (typeof onStep === 'function') statsMiddleware.on('step', onStep);
  if (typeof onExpire === 'function') statsMiddleware.on('expire', onExpire);

  // start timing
  addInterval();
  if (step > 0) setInterval(addInterval, step);

  return statsMiddleware;
}

// export busybody and the default sanitize function
module.exports = busybody;
busybody.sanitize = defaultSanitize;